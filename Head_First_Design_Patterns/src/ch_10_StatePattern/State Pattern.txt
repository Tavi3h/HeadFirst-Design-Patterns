状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

UML-410

secVer相对与firstVer来说：
1、将每个状态的行为局部化到它自己的类中。
2、将容易产生问题的if语句删除，以方便日后维护。
3、让每一个状态“对修改关闭”，让糖果机“对扩展开放”，因为可以加入新的状态类。
4、创建一个新的代码基和类结构，更容易阅读和理解

Q:  ConcreteState总是决定接下来的状态是什么吗？
A:  并非总是如此，Context也可以决定状态转换的流向。
	一般来讲，当状态转换是固定的时候，就适合放在Context中；然而当转换是更动态的时候，通常放在状态类中。
	将状态转换放在状态类中的缺点是-----状态类之间产生了依赖。
	(在GumballMachine--secVer实现中，我们通过使用Context上的getter方法把依赖减到最小，而不是硬编码具体的状态类)
	*注意：在做这个决策的同时，也等于是在为另一件事情做决策：
	当系统进化时，究竟哪个类(Context or ConcreteState)是对修改关闭的。
Q:  客户会直接和状态交互吗？
A:	不会。全盘了解状态是Context的工作，客户根本不了解，所以不会直接与状态联系。


状态模式和策略模式：
状态模式与策略模式是双胞胎，在出生时才分开。

以状态模式而言，我们将一群行为封装在状态对象中，Context的行为随时可
委托到哪些状态对象中的一个。随着时间的流逝，当前状态在状态对象集合中游走改变，
以反映出Context内部的状态，因此Context的行为也会跟着改变。但是Context的客户对于状态
对象了解不多，甚至根本浑然不觉。

而以策略模式而言，客户通常主动指定Context所要组合的策略对象时哪一个。现在固然策略模式
让我们具有弹性，能够在运行时改变策略，但对于某个Context对象来说，通常都只有一个最适合
的策略对象。

一般来说，我们把策略模式想成时除了继承之外的一种弹性替代方案。
把状态模式想成不用在Context中放置许多条件判断的替代方案。通过将行为
包装进状态对象中，你可以通过在cContext内简单地改变状态对象来改变Context的行为。

要点：
1、状态模式允许一个对象基于内部状态而拥有不同的行为。
2、和程序状态机（PSM）不同，状态模式用类代表状态。
3、Context会将行为委托给当提前状态对象。
4、通过将每个状态封装进一个类，我们把以后要做的任何改变局部化了。
5、状态模式和策略模式有相同的类图，但是意图不同。
6、策略模式通常会用行为或者算法来配置Context类。
7、状态模式允许Context随着状态的改变而改变行为。
8、状态转换可以由State或是Context类控制。
9、使用状态模式通常会导致设计中的类的数目大量增加。
10、状态类可以被多个Context实例共享。