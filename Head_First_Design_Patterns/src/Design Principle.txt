总则：建立弹性的设计，建立可以、维护可以应付变化的OO系统。

***所有原则都应该在有帮助的时候才遵守。所有的设计都不免需要折衷。***

具体原则：
1、找出应用中可能需要变化之处，把它们独立出来，不要和哪些不需要变化的代码混在一起
2、针对接口（超类型）编程，而不是针对实现编程。[1]
3、多用组合，少用继承
4、为了交互对象之间的松耦合设计而努力
5、类应该对扩展开放，对修改关闭。
6、依赖抽象，不要依赖具体类（依赖倒置原则）
7、最少知识原则：只和你的密友谈话(这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统的一部分会影响到其它部分)。[2]
8、好莱坞原则：别调用我们，我们会调用你。[3]
9、一个类应该只有一个引起变化的原因（单一责任）[4]



=====================================================
[1]
在设计模式中，所谓的“实现一个接口”并不一定表示“写一个类，并利用implements关键字来实现某个接口”，“实现一个接口”泛指实现某个超类型（可以是类或接口）的某个方法。
=====================================================
[2]
具体方针：
就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：
a、该对象本身
b、被当作方法的参数而传递进来的对象
c、此方法所创建或实例化的任何对象
d、对象的任何组件（被实例变量所引用的任何对象，Has - A 关系）
a b c要求我们，如果某对象是调用其它的方法的返回的结果，不要调用该对象的方法。

Example_1:

// 不采用该原则
public float getTemp() {
	Thermometer tm = station.getThermometer(); // 从气象站对象取得温度计对象
	return tm.getTemperature(); // 从温度计对象得到温度
}

// 采用该原则
public float getTemp() {
	return station.getTemperature(); // 在气象站类中添加一个方法用来向温度计请求温度，这样可以减少我们所依赖的类的数目
}

Example_2:
// 下面是一个汽车类，展示在遵守该原则下调用方法的各种做法：

public class Car {

	Engine engine;                           // 这是类的一个组件，我们能够调用它的方法
	// other instance variable ...   
	 
	public Car() {
		// initialization ...
	}
	
	public void start(Key key) {             // 被当作参数传进来的对象，其方法可以调用
	
		Doors doors = new Doors();           // 创建了一个新的对象，它的方法可以调用
		boolean authorized = key.turns();
		if (authorized) {
			engine.start();                  // 组件的方法可以调用
			updateDashboardDisplay();        // 可以调用同一个对象内的本地方法
			doors.lock();                    // 可以调用你所创建或实例化的对象的方法
		}
		
	}
	
	public void updateDashboardDisplay() {
		// update display ...
	}
}
=====================================================
[3]
该原则可以给我们一种防止“依赖腐败”的方法。
当高层组件依赖低层组件，而低层组件又依赖高层组件，而高层组件又依赖边侧组件，而边侧组件又依赖低层组件时，依赖腐败就发生了。
在这种情况下，很难轻易搞清楚该系统时如何设计的。

在好莱坞原则下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。
高层组件对待低层组件的方式是“别调用我们，我们会调用你”。
Q : 低层组件不可以调用高层组件中的方法吗？
A : 并不尽然。事实上，低层组件在结束时，尝尝会调用从超类中继承来的方法。我们实际要做的是，避免让高层和低层组件之间有明显的环状依赖。
=====================================================
[4]
内聚：用来度量一个类或模块紧密地达到单一目的或责任。
当一个模块或一个类被设计成只支持一组相关功能时，我们说它具有高内聚；反之，当被设计成支持一组不相关功能时，我们说它具有低内聚。
内聚是一个比单一责任原则更普遍的概念，但两者其实关系是很密切的。遵守这个原则的类很容易具有很高的凝聚力，比背负许多责任的低内聚类更容易维护。