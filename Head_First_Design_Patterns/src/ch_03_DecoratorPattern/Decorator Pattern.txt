装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更由弹性的替代方案。

符合开放-关闭原则

1、装饰者和被装饰者对象有相同的超类型
2、可以用一个或多个装饰者来包装一个对象
3、既然二者有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它。
4、装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的
5、对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象
6、使用抽象类和接口都可以，如果当前代码运行良好则避免修改

要点：
1、继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式。
2、在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码。
3、组合和委托可以用于在运行时动态地加上新的行为。
4、除了继承，装饰者模式也可以让我们扩展行为。
5、装饰者模式意味着一群装饰者类，这些类用来包装具体组件
6、装饰者类反映出被装饰的组件类型（事实上，它们具有相同的类型，都经过接口或继承实现）
7、装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的
8、你可以用无数个装饰者包装一个组件
9、装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型
10、装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。

starbuck-UML-P92