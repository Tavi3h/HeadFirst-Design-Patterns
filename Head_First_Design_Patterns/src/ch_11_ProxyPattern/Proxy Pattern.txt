代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。

代理要做的事情：控制和管理访问。
代理的方式有很多种。代理以通过Internet为它们的代理对象搬运的整个方法调用而出名，它也可以代替某些懒惰的对象做一些事。

一、远程代理

=============================================================================================================
远程代理好比“远程对象的本地代表”。
远程对象：这是一种对象，活在不同的JVM堆中，更一般的说法是在不同地址空间运行的远程对象。
本地代表：这是一种可以由本地方法调用的对象，其行为会转发到远程对象中。

在监视糖果机状态的例子中：
糖果监视器是客户对象，它以为沟通的是真正的糖果机，但实际上与它沟通的是代理。再由代理通过网络与真正的糖果机沟通。

||
||本地堆：
||	|--糖果监视器：客户对象，改为与代理沟通。
||	|--代理：本地代表，可以假装自己是远程对象，但其实只是一个中间角色。
||远程堆：
||	|--糖果机：远程对象，拥有一些真正做事的方法。
||	
	
客户对象所做的就像是再做远程方法调用，但其实只是调用本地堆中的“代理”对象上的方法，再由代理处理所有网络通信的低层细节。

如何设计？

我们需要一些辅助对象帮我们进行沟通。这些辅助对象使客户就像在调用本地对象的方法一样。
客户调用客户辅助对象上的方法，仿佛客户辅助对象就是真正的服务。客户辅助对象再负责为我们转发这些请求。
但是客户对象并不是真正的远程服务。虽然操作看起来很像，因为它具有服务所宣称的相同的方法，
但它并不真正拥有客户所期望的方法逻辑。客户辅助对象会联系服务器，传送打包好的方法调用信息（方法名、变量...），然后等待服务器的返回。
在服务端，服务辅助对象通过Socket链接从客户辅助对象中接受请求，将调用的信息解包，然后调用真正服务对象上的方法。
所以对于服务对象来说，调用是本地的，来自服务辅助对象，而不是远程客户。
服务辅助对象从服务中得到返回值，将它打包，然后传回客户辅助对象（同样通过Socket），客户辅助对象堆信息进行解包，最后将返回值交给客户对象。                                                                                                                                                                                                                                                                                                                       。

||
||客户堆：
||	|--客户对象：客户对象以为在和真正的服务沟通，以为客户辅助对象就是能够真正做事的东西。
||	|--客户辅助对象(RMI STUB)：客户辅助对象假装自己就是服务，但其实它只是“真东西”的代理。
||服务器堆：
||	|--服务辅助对象(RMI SKEL)：服务辅助对象从客户辅助对象处取得请求，对它解包并调用真正服务上的方法。
||	|--服务对象是真正提供服务的地方，它的方法真正在做事情。
||

RMI(即Remote Method Invoke 远程方法调用)。
RMI提供了客户辅助对象和服务辅助对象，为客户辅助对象创建和服务对象相同的方法。
RMI的好处在于你不必亲自写任何网络或I/O代码。
客户调用远程方法（即真正的服务所在）就和在运行在客户自己的本地JVM上对对象进行正常方法调用一样。

在Java中,只要一个类实现了java.rmi.Remote接口,即可成为存在于服务器端的远程对象,供客户端访问并提供一定的服务。
=============================================================================================================

二、虚拟代理

=============================================================================================================
虚拟代理作为创建开销大的对象的代表。虚拟代理经常直到我们真正需要一个对象的时候才创建它。
当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。
=============================================================================================================

三、保护代理

=============================================================================================================
Java在java.lang.reflect包中有自己的代理支持，利用这个包你可以在运行时动态地创建一个代理类，实现一个或多个接口，
并将方法的调用转发到你所指定的类。因为实际的代理类是在运行时创建的，我们称这个技术为动态代理。 UML-P474

保护代理是一种根据访问权限决定客户可访问对象的代理。

因为Java已经为你创建了Proxy类，所以你需要有办法来告诉Proxy类你要做什么。你不能像以前一样把代码放在Proxy类中，因为
Proxy类不是你直接实现的。既然这样的代码不能放在Proxy类中，那么要放在哪里呢？
放在InvocationHandler中。InvocationHandler的工作是响应代理的任何调用。你可以把InvocationHandler想成是代理收到
方法调用后，请求做实际工作的对象。

invoke()方法调用图解P480
=============================================================================================================

四、其它代理

=============================================================================================================
1、防火墙代理（Firewall Proxy）：控制网络资源的访问，保护主题免于“坏客户”的侵害。
2、智能引用代理（Smart Reference Proxy）：当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数
3、缓存代理（Caching Proxy）：为开销大的运算结果提供暂时的储存，它允许多个客户共享结果，以减少计算或网络延迟。
4、同步代理（Synchronization Proxy）：在多线程的情况下为主题提供安全的访问。
5、复杂隐藏代理（Complexity Hiding Proxy）：用来隐藏一个类的复杂度，并进行访问控制。有时也成为外观代理（Facade Proxy）。
6、写入时复制代理（Copy-On-Write Proxy）：用来控制对象的复制，方法时延迟对象的复制，直到客户真正需要为止。这是虚拟代理的变体。
=============================================================================================================

Q&A - P486

要点：
1、代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有很多种；
2、远程代理管理客户和远程对象之间的交互；
3、虚拟代理控制访问实例化开销大的对象；
4、保护代理基于调用者控制对对象方法的访问；
5、代理模式有很多变体；
6、代理在结构上类似装饰者，但是目的不同：装饰者模式为对象加上行为，而代理则是控制访问；
7、Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器。
8、代理会造成你的设计中类的数目增加。
