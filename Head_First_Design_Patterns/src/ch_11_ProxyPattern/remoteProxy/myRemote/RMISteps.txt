
Step 1：

[1]	扩展java.rmi.Remote接口。

	该接口是一个“记号”接口，所以不具备方法。
	对于RMI来说，这个接口具有特别的意义，所以我们遵守规则不直接实现该接口，
	而是用一个自定义的接口去继承该接口。
	
[2]	声明所有的方法都会抛出RemoteException。

	客户使用远程接口调用服务。换句话说，客户会调用实现远程接口的Stub上的方法，
	而Stub底层用到了网络和I/O，所以各种坏事情都可能会发生。客户必须认识到风险，
	通过处理或声明远程异常来解决。如果接口中的方法声明了异常，任何在接口类型的
	引用上调用方法的代码也必须处理或声明异常。
	
[3]	确定变量和返回值是属于原语(primitive)类型或者可序列化(Serializable)类型。

	远程方法的变量和返回值，必须是原语类型或Serializable类型。
	这是因为远程方法的变量必须被打包并通过网络运送，这需要序列化来完成。
	如果使用原语类型、字符串和许多API中内定类型（包括数组和集合）都不会有问题。
	如果你要使用自己定义的类，则这个类必须实现Serializable接口。
	

Step 2：

[1]	实现远程接口。
	
	你的服务必须实现远程接口，也就是客户将要调用的方法的接口。
	
[2]	扩展UnicastRemoteObject

	为了要成为远程服务对象，你的对象需要某些“远程的”功能。最简单的方式
	是扩展java.rmi.server.UnicastRemoteObject，让超类帮你做这些工作。
	
[3]	设计一个不带变量的构造器，并声明RemoteException

	新的超类UnicastRemoteObject带来一个小问题：它的构造器抛出RemoteException。
	唯一解决的办法就是为你的远程实现声明一个构造器，这样就有了一个声明RemoteException
	的地方。当类被实例化的时候，超类的构造器总会被调用，如果超类的构造器抛出异常，
	那么你只能声明子类的构造器也抛出异常。

[4]	用RMI Registry注册此服务。

	现在你已经有了一个远程服务了，必须让它可以被远程客户调用。你要做的是将此服务实例化，
	然后放进RMI registry中（记得RMI registry正在运行，否则注册会失败）。当注册这个实现对象时，
	RMI系统注册的其实是stub，因为这是客户真正需要的。注册服务使用了java.rmi.Naming类的rebind()方法。


对于RMI，程序员最常犯的三个错误：
1、忘了在启动远程服务前先进行RMI Registry（要用Naming.rebind()注册服务，RMI Registry必须是运行的）。
2、忘了让变量和返回值的类型成为可序列化的类型（编译器无法发现，只会在运行时发现.....也许可以用Annotation解决）。	
3、忘了给客户提供stub类。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	